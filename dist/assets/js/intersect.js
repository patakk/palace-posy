class myVec{constructor(t,n,i=0){this.x=t,this.y=n,this.z=i}dist(t){return Math.sqrt((this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y)+(this.z-t.z)*(this.z-t.z))}angleBetween(t){const n=this.dot(t)/(this.mag()*t.mag());let i;return i=Math.acos(Math.min(1,Math.max(-1,n))),i*=Math.sign(this.cross(t).z||1),i}cross(t){const n=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,e=this.x*t.y-this.y*t.x;return new myVec(n,i,e)}dot(t){return this.x*(t.x||0)+this.y*(t.y||0)+this.z*(t.z||0)}mag(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}div(t){return myVec(this.x/t,this.y/t,this.z/t)}normalize(){return this.div(this.mag())}}function subVec(t,n){return new myVec(t.x-n.x,t.y-n.y,t.z-n.z)}function addVec(t,n){return new myVec(t.x+n.x,t.y+n.y,t.z+n.z)}function issamepoint(t,n){return t.dist(n)<.1}function radians(t){return t/180*Math.PI}function findLineIntersection(t,n,i,e){var s=subVec(n,t),r=subVec(e,i),y=subVec(i,t);let h=s.angleBetween(r);if(h<radians(.1))return!1;let a=s.angleBetween(y);var o=subVec(e,i);o.normalize();var u=-y.mag()*sin(a)/sin(h);return!(u<0||u>r.mag())&&(o.mult(u),addVec(i,o))}function onSegment(t,n,i){return n.x<=max(t.x,i.x)&&n.x>=min(t.x,i.x)&&n.y<=max(t.y,i.y)&&n.y>=min(t.y,i.y)}function triorientation(t,n,i){var e=(n.y-t.y)*(i.x-n.x)-(n.x-t.x)*(i.y-n.y);return 0==e?0:e>0?1:2}function doLinesIntersect(t,n,i,e){var s=triorientation(t,n,i),r=triorientation(t,n,e),y=triorientation(i,e,t),h=triorientation(i,e,n);return s!=r&&y!=h||!(0!=s||!onSegment(t,i,n))||!(0!=r||!onSegment(t,e,n))||!(0!=y||!onSegment(i,t,e))||!(0!=h||!onSegment(i,n,e))}function isinside(t,n){let i=0;for(let e=0,s=n.length-1;e<n.length;s=e++){let r=n[e],y=n[s];y.y<=t.y?r.y>t.y&&isLeft(y,r,t)>0&&i++:r.y<=t.y&&isLeft(y,r,t)<0&&i--}return 0!=i}function isLeft(t,n,i){return(n.x-t.x)*(i.y-t.y)-(i.x-t.x)*(n.y-t.y)}